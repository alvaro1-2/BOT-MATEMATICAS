from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    CallbackQueryHandler,
)
import logging
import random
import time

# Configurar el registro de logs
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Funci√≥n para manejar errores globalmente
async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Maneja los errores y excepciones."""
    logger.error(msg="Ocurri√≥ un error:", exc_info=context.error)
    # Puedes implementar m√°s l√≥gica aqu√≠ si lo deseas, como notificar al administrador, etc.

# Funci√≥n para iniciar el bot y mostrar el men√∫ principal
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton("√Ålgebra üî¢", callback_data='algebra')],
        [InlineKeyboardButton("Trigonometr√≠a üìê", callback_data='trigonometria')],
        [InlineKeyboardButton("Aritm√©tica üßÆ", callback_data='aritmetica')],
        [InlineKeyboardButton("Geometr√≠a üìè", callback_data='geometria')],
        [InlineKeyboardButton("Se√±or Meeseeks üîµ", callback_data='meeseeks')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    if update.message:
        await update.message.reply_text(
            "üìö *Men√∫ Principal*:\nSeleccione una categor√≠a:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    elif update.callback_query:
        await update.callback_query.edit_message_text(
            "üìö *Men√∫ Principal*:\nSeleccione una categor√≠a:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )

# Funci√≥n para manejar las interacciones con los botones
async def button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data

    # Men√∫ principal
    if data == 'algebra':
        keyboard = [
            [InlineKeyboardButton("N√∫meros Reales y Complejos", callback_data='numeros_reales_complejos')],
            [InlineKeyboardButton("Ecuaciones e Inecuaciones", callback_data='ecuaciones_inecuaciones')],
            [InlineKeyboardButton("Sistemas de Ecuaciones", callback_data='sistemas_ecuaciones')],
            [InlineKeyboardButton("Expresiones Algebraicas", callback_data='expresiones_algebraicas')],
            [InlineKeyboardButton("Funciones Reales de Variable Real", callback_data='funciones_reales')],
            [InlineKeyboardButton("‚¨ÖÔ∏è Volver al Men√∫ Principal", callback_data='start')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            "üî¢ *√Ålgebra*:\nSeleccione un subtema:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )

    elif data == 'trigonometria':
        await query.edit_message_text("üìê La funcionalidad de Trigonometr√≠a a√∫n no est√° disponible.")

    elif data == 'aritmetica':
        await query.edit_message_text("üßÆ La funcionalidad de Aritm√©tica a√∫n no est√° disponible.")

    elif data == 'geometria':
        await query.edit_message_text("üìè La funcionalidad de Geometr√≠a a√∫n no est√° disponible.")

    elif data == 'meeseeks':
        await send_meeseeks(update, context)

    elif data == 'start':
        # Volver al men√∫ principal
        await start(update, context)

    # Subtemas de √Ålgebra
    elif data == 'numeros_reales_complejos':
        keyboard = [
            [InlineKeyboardButton("Operaciones con N√∫meros Reales", callback_data='operaciones_numeros_reales')],
            [InlineKeyboardButton("Intervalos", callback_data='intervalos')],
            [InlineKeyboardButton("Valor Absoluto", callback_data='valor_absoluto')],
            [InlineKeyboardButton("Representaci√≥n Binomial", callback_data='representacion_binomial')],
            [InlineKeyboardButton("M√≥dulo y Conjugado", callback_data='modulo_conjugado')],
            [InlineKeyboardButton("‚¨ÖÔ∏è Volver a √Ålgebra", callback_data='algebra')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            "üî¢ *N√∫meros Reales y Complejos*:\nSeleccione un tema:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )

    elif data == 'ecuaciones_inecuaciones':
        keyboard = [
            [InlineKeyboardButton("Ecuaciones de Primer y Segundo Grado", callback_data='ecuaciones_una_variable')],
            [InlineKeyboardButton("Ecuaciones Bicuadradas", callback_data='ecuaciones_bicuadradas')],
            [InlineKeyboardButton("Inecuaciones de Primer y Segundo Grado", callback_data='inecuaciones_una_variable')],
            [InlineKeyboardButton("‚¨ÖÔ∏è Volver a √Ålgebra", callback_data='algebra')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            "üìè *Ecuaciones e Inecuaciones*:\nSeleccione un tema:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )

    elif data == 'sistemas_ecuaciones':
        keyboard = [
            [InlineKeyboardButton("Sistemas Lineales", callback_data='sistemas_lineales')],
            [InlineKeyboardButton("M√©todos de Cramer y Gauss", callback_data='metodos_cramer_gauss')],
            [InlineKeyboardButton("Sistemas de Inecuaciones", callback_data='sistemas_inecuaciones')],
            [InlineKeyboardButton("Programaci√≥n Lineal", callback_data='programacion_lineal')],
            [InlineKeyboardButton("‚¨ÖÔ∏è Volver a √Ålgebra", callback_data='algebra')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            "üìê *Sistemas de Ecuaciones*:\nSeleccione un tema:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )

    elif data == 'expresiones_algebraicas':
        keyboard = [
            [InlineKeyboardButton("Operaciones", callback_data='operaciones_exp_alg')],
            [InlineKeyboardButton("Potenciaci√≥n", callback_data='potenciacion')],
            [InlineKeyboardButton("Radicaci√≥n", callback_data='radicacion')],
            [InlineKeyboardButton("Polinomios con Coeficientes en ‚Ñù", callback_data='polinomios_coeficientes')],
            [InlineKeyboardButton("Grado de Expresiones Algebraicas", callback_data='grado_expresiones')],
            [InlineKeyboardButton("Operaciones con Polinomios", callback_data='operaciones_polinomios')],
            [InlineKeyboardButton("Divisi√≥n de Polinomios", callback_data='division_polinomios')],
            [InlineKeyboardButton("Teorema del Resto", callback_data='teorema_resto')],
            [InlineKeyboardButton("Teorema del Factor", callback_data='teorema_factor')],
            [InlineKeyboardButton("Productos Notables", callback_data='productos_notables')],
            [InlineKeyboardButton("Factorizaci√≥n", callback_data='factorizacion')],
            [InlineKeyboardButton("MCD y MCM de Polinomios", callback_data='mcd_mcm_polinomios')],
            [InlineKeyboardButton("Teorema Fundamental del √Ålgebra", callback_data='teorema_fundamental')],
            [InlineKeyboardButton("Relaci√≥n entre Ra√≠ces y Coeficientes", callback_data='raices_coeficientes')],
            [InlineKeyboardButton("‚¨ÖÔ∏è Volver a √Ålgebra", callback_data='algebra')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            "üßÆ *Expresiones Algebraicas*:\nSeleccione un tema:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )

    elif data == 'funciones_reales':
        keyboard = [
            [InlineKeyboardButton("Dominio y Rango", callback_data='dominio_rango')],
            [InlineKeyboardButton("Representaci√≥n de Funciones", callback_data='representacion_funciones')],
            [InlineKeyboardButton("Funciones Elementales", callback_data='funciones_elementales')],
            [InlineKeyboardButton("Funciones Par e Impar", callback_data='funciones_par_impar')],
            [InlineKeyboardButton("Funciones Mon√≥tonas", callback_data='funciones_monotonas')],
            [InlineKeyboardButton("Funciones Inyectivas y Sobreyectivas", callback_data='funciones_iny_sobre')],
            [InlineKeyboardButton("Funciones Inversas", callback_data='funciones_inversas')],
            [InlineKeyboardButton("Funci√≥n Exponencial", callback_data='funcion_exponencial')],
            [InlineKeyboardButton("Funci√≥n Logar√≠tmica", callback_data='funcion_logaritmica')],
            [InlineKeyboardButton("Modelaci√≥n con Funciones", callback_data='modelacion_funciones')],
            [InlineKeyboardButton("‚¨ÖÔ∏è Volver a √Ålgebra", callback_data='algebra')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            "üìà *Funciones Reales de Variable Real*:\nSeleccione un tema:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )

    # Aqu√≠ manejamos los subtemas finales que env√≠an im√°genes y textos
    else:
        # Asumimos que el data coincide con el nombre de la funci√≥n
        # Llamamos a la funci√≥n correspondiente
        await send_topic(update, data)

# Funci√≥n para enviar el contenido de cada tema
async def send_topic(update: Update, topic_key):
    topic_dict = {
        'operaciones_numeros_reales': ('images/operaciones_numeros_reales.png', "‚ûï‚ûñ‚úñÔ∏è‚ûó *Operaciones con N√∫meros Reales*"),
        'intervalos': ('images/intervalos.png', "üìè *Intervalos en la Recta Real*"),
        'valor_absoluto': ('images/valor_absoluto.png', "‚ûï *Valor Absoluto*"),
        'representacion_binomial': ('images/representacion_binomial.png', "üî¢ *Representaci√≥n Binomial de un N√∫mero Complejo*"),
        'modulo_conjugado': ('images/modulo_conjugado.png', "üìê *M√≥dulo y Conjugado. Propiedades*"),
        'ecuaciones_una_variable': ('images/ecuaciones_una_variable.png', "‚ûó *Ecuaciones de Primer y Segundo Grado con una Variable*"),
        'ecuaciones_bicuadradas': ('images/ecuaciones_bicuadradas.png', "‚úñÔ∏è *Ecuaciones Bicuadradas*"),
        'inecuaciones_una_variable': ('images/inecuaciones_una_variable.png', "‚ûñ *Inecuaciones de Primer y Segundo Grado con una Variable*"),
        'sistemas_lineales': ('images/sistemas_lineales.png', "üìù *Sistemas de Ecuaciones Lineales*"),
        'metodos_cramer_gauss': ('images/metodos_cramer_gauss.png', "üìä *M√©todos de Cramer y Gauss*"),
        'sistemas_inecuaciones': ('images/sistemas_inecuaciones.png', "üìà *Sistemas de Inecuaciones*"),
        'programacion_lineal': ('images/programacion_lineal.png', "üíπ *Introducci√≥n a la Programaci√≥n Lineal*"),
        'operaciones_exp_alg': ('images/operaciones_exp_alg.png', "üßÆ *Operaciones con Expresiones Algebraicas*"),
        'potenciacion': ('images/potenciacion.png', "üí• *Potenciaci√≥n*"),
        'radicacion': ('images/radicacion.png', "üåø *Radicaci√≥n*"),
        'polinomios_coeficientes': ('images/polinomios_coeficientes.png', "üî¢ *Polinomios con Coeficientes en ‚Ñù*"),
        'grado_expresiones': ('images/grado_expresiones.png', "üìè *Grado de Expresiones Algebraicas*"),
        'operaciones_polinomios': ('images/operaciones_polinomios.png', "‚ûï *Operaciones con Polinomios*"),
        'division_polinomios': ('images/division_polinomios.png', "‚ûó *Divisi√≥n de Polinomios*"),
        'teorema_resto': ('images/teorema_resto.png', "üß© *Teorema del Resto*"),
        'teorema_factor': ('images/teorema_factor.png', "üîë *Teorema del Factor*"),
        'productos_notables': ('images/productos_notables.png', "üåü *Productos Notables*"),
        'factorizacion': ('images/factorizacion.png', "üõ†Ô∏è *Factorizaci√≥n*"),
        'mcd_mcm_polinomios': ('images/mcd_mcm_polinomios.png', "üîó *MCD y MCM de Polinomios*"),
        'teorema_fundamental': ('images/teorema_fundamental_algebra.png', "üìö *Teorema Fundamental del √Ålgebra*"),
        'raices_coeficientes': ('images/raices_coeficientes.png', "üå± *Relaci√≥n entre Ra√≠ces y Coeficientes*"),
        'dominio_rango': ('images/dominio_rango.png', "üåê *Dominio y Rango de una Funci√≥n*"),
        'representacion_funciones': ('images/representacion_funciones.png', "üìä *Representaci√≥n de Funciones*"),
        'funciones_elementales': ('images/funciones_elementales.png', "üî¢ *Funciones Elementales*"),
        'funciones_par_impar': ('images/funciones_par_impar.png', "‚öñÔ∏è *Funciones Par e Impar*"),
        'funciones_monotonas': ('images/funciones_monotonas.png', "üìà *Funciones Mon√≥tonas*"),
        'funciones_iny_sobre': ('images/funciones_inyectivas_sobreyectivas.png', "üîÑ *Funciones Inyectivas y Sobreyectivas*"),
        'funciones_inversas': ('images/funciones_inversas.png', "üîÉ *Funciones Inversas*"),
        'funcion_exponencial': ('images/funcion_exponencial.png', "üíπ *Funci√≥n Exponencial*"),
        'funcion_logaritmica': ('images/funcion_logaritmica.png', "üìà *Funci√≥n Logar√≠tmica*"),
        'modelacion_funciones': ('images/modelacion_funciones.png', "üåç *Modelaci√≥n del Mundo Real con Funciones*")
    }

    if topic_key in topic_dict:
        image_path, caption = topic_dict[topic_key]
        await send_photo_with_caption(update.callback_query, image_path, caption)
    else:
        await update.callback_query.edit_message_text("Lo siento, este contenido no est√° disponible.")

# Funci√≥n para enviar fotos con mensaje y manejar excepciones
async def send_photo_with_caption(query, image_path: str, caption: str):
    try:
        with open(image_path, 'rb') as photo:
            await query.message.reply_photo(photo=photo, caption=caption, parse_mode='Markdown')
    except FileNotFoundError:
        await query.message.reply_text("Lo siento, la imagen no est√° disponible en este momento.")
    except Exception as e:
        logger.error(f"Error al enviar la imagen: {e}")
        await query.message.reply_text("Ocurri√≥ un error al enviar la imagen.")

# Funci√≥n para enviar una imagen y una frase aleatoria de Se√±or Meeseeks
async def send_meeseeks(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query

    frases_meeseeks = [
        "¬°Soy el Se√±or Meeseeks! ¬°M√≠rame!",
        "¬°Puedo hacerlo!",
        "¬°La existencia es dolor para un Meeseeks!",
        "¬°Ooh, s√≠! ¬°Claro que s√≠!",
        "Los Meeseeks no suelen existir tanto tiempo.",
        "¬°Estamos creados para servir un prop√≥sito singular!",
        "¬°Vamos, Jerry! ¬°Tienes que relajarte!",
        "Lo siento, pero es tu culpa que est√©s atascado con nosotros.",
        "¬°Todos queremos morir! ¬°Somos Meeseeks!",
        "¬°Vivimos para servir!",
        "¬°Solo intenta relajarte!",
        "¬°El Se√±or Meeseeks te ayudar√°!"
    ]

    frase = random.choice(frases_meeseeks)
    image_path = 'images/meeseeks.png'  # Aseg√∫rate de tener esta imagen en la carpeta 'images'

    try:
        with open(image_path, 'rb') as photo:
            await query.message.reply_photo(photo=photo, caption=frase)
    except FileNotFoundError:
        await query.message.reply_text(frase)
    except Exception as e:
        logger.error(f"Error al enviar la imagen de Meeseeks: {e}")
        await query.message.reply_text("Ocurri√≥ un error al enviar la imagen de Meeseeks.")

# Configuraci√≥n principal del bot
def main():
    # Reemplaza 'YOUR_BOT_TOKEN' con el token de tu bot
    TOKEN = '8099377584:AAG_yiQtBroxjgtnsuwnTmQfDZ622-PfnVY'

    # Construir la aplicaci√≥n
    application = Application.builder().token(TOKEN).build()

    # Agregar manejador de errores
    application.add_error_handler(error_handler)

    # Comandos principales
    application.add_handler(CommandHandler('start', start))
    application.add_handler(CommandHandler('comandos', start))

    # Manejo de botones
    application.add_handler(CallbackQueryHandler(button))

    # Iniciar el bot y mantenerlo corriendo
    application.run_polling(drop_pending_updates=True)

if __name__ == '__main__':
    while True:
        try:
            main()
        except Exception as e:
            logger.error(f"El bot se detuvo debido a un error: {e}")
            logger.info("Reiniciando el bot en 5 segundos...")
            time.sleep(5)
